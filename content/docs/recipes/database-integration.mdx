---
title: Database Integration
description: Learn how to integrate databases with your Seyfert bot
---
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

# Database Integration

This guide shows how to integrate different databases with your Seyfert bot. We'll cover both SQL and NoSQL options.

## Choosing a Database

Consider these factors when choosing a database:
- Data structure requirements
- Scaling needs
- Hosting environment
- Budget constraints

## MongoDB Integration

Here's how to integrate MongoDB with your Seyfert bot:

<Tabs items={['Installation', 'Configuration', 'Usage']}>
  <Tab value="Installation">
```bash
npm install mongoose
```
  </Tab>
  <Tab value="Configuration">
```ts
// src/config/database.ts
import mongoose from 'mongoose';

export async function connectDatabase() {
    try {
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('Connected to MongoDB');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
}
```
  </Tab>
  <Tab value="Usage">
```ts
// src/models/User.ts
import { Schema, model } from 'mongoose';

const userSchema = new Schema({
    discordId: { type: String, required: true, unique: true },
    balance: { type: Number, default: 0 },
    lastDaily: Date
});

export const User = model('User', userSchema);

// Using in a command
@Declare({
    name: 'balance',
    description: 'Check your balance'
})
export class BalanceCommand extends Command {
    async run(ctx: CommandContext) {
        const user = await User.findOne({ discordId: ctx.author.id });
        
        if (!user) {
            return ctx.write({
                content: 'You don\'t have an account yet!'
            });
        }
        
        return ctx.write({
            content: `Your balance is: ${user.balance}`
        });
    }
}
```
  </Tab>
</Tabs>

## PostgreSQL with Prisma

Here's how to use PostgreSQL with Prisma:

<Tabs items={['Installation', 'Schema', 'Usage']}>
  <Tab value="Installation">
```bash
npm install @prisma/client
npm install prisma --save-dev
npx prisma init
```
  </Tab>
  <Tab value="Schema">
```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  discordId String   @unique
  balance   Int      @default(0)
  lastDaily DateTime?
}
```
  </Tab>
  <Tab value="Usage">
```ts
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

// Using in a command
@Declare({
    name: 'daily',
    description: 'Claim your daily reward'
})
export class DailyCommand extends Command {
    async run(ctx: CommandContext) {
        const user = await prisma.user.upsert({
            where: { discordId: ctx.author.id },
            update: {
                balance: { increment: 100 },
                lastDaily: new Date()
            },
            create: {
                discordId: ctx.author.id,
                balance: 100,
                lastDaily: new Date()
            }
        });
        
        return ctx.write({
            content: `You claimed your daily reward! New balance: ${user.balance}`
        });
    }
}
```
  </Tab>
</Tabs>

## Redis for Caching

Using Redis for caching frequently accessed data:

```ts
import { createClient } from 'redis';

const redis = createClient({
    url: process.env.REDIS_URL
});

redis.on('error', err => console.error('Redis Client Error', err));

await redis.connect();

// Caching example
async function getCachedUserData(userId: string) {
    const cached = await redis.get(`user:${userId}`);
    
    if (cached) {
        return JSON.parse(cached);
    }
    
    const userData = await fetchUserData(userId);
    await redis.set(`user:${userId}`, JSON.stringify(userData), {
        EX: 3600 // 1 hour
    });
    
    return userData;
}
```

## Best Practices

1. **Connection Management**
   - Handle connection errors gracefully
   - Implement connection pooling
   - Use environment variables for credentials

2. **Data Access Patterns**
   - Implement repository pattern
   - Use transactions when needed
   - Cache frequently accessed data

3. **Error Handling**
   - Handle database errors gracefully
   - Provide user-friendly error messages
   - Log database errors for debugging

```ts
// Example repository pattern
class UserRepository {
    async getUser(discordId: string) {
        try {
            return await User.findOne({ discordId });
        } catch (error) {
            console.error('Error fetching user:', error);
            throw new Error('Failed to fetch user data');
        }
    }
    
    async updateBalance(discordId: string, amount: number) {
        try {
            return await User.findOneAndUpdate(
                { discordId },
                { $inc: { balance: amount } },
                { new: true }
            );
        } catch (error) {
            console.error('Error updating balance:', error);
            throw new Error('Failed to update balance');
        }
    }
}
```

## Security Considerations

1. **Data Protection**
   - Use prepared statements/parameterized queries
   - Implement proper access control
   - Encrypt sensitive data

2. **Connection Security**
   - Use SSL/TLS for database connections
   - Implement proper firewall rules
   - Regularly rotate credentials

<Callout type="warning">
Never commit database credentials to version control. Always use environment variables or secure secret management.
</Callout>

## Performance Tips

1. **Indexing**
   - Create appropriate indexes
   - Monitor query performance
   - Use database-specific optimization tools

2. **Connection Pooling**
   - Implement connection pooling
   - Configure pool size appropriately
   - Monitor pool metrics

3. **Caching Strategy**
   - Implement appropriate caching
   - Use cache invalidation strategies
   - Monitor cache hit rates

## Deployment Considerations

1. **Migration Strategy**
   - Plan database migrations
   - Test migrations thoroughly
   - Have rollback plans

2. **Monitoring**
   - Monitor database performance
   - Set up alerts for issues
   - Regular backups

<Callout>
Remember to handle database operations asynchronously and implement proper error handling to ensure your bot remains responsive.
</Callout> 